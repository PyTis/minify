#!/usr/bin/env python
# -*- coding: utf-8 -*-
# ##############################################################################
# The contents of this file are subject to the PyTis Public License Version    #
# 3.0 (the "License"); you may not use this file except in compliance with     #
# the License. You may obtain a copy of the License at                         #
#                                                                              #
#     http://www.PyTis.com/License/                                            #
#                                                                              #
#     Copyright Â© 2024 Josh Lee                                               #
#                                                                              #
# Software distributed under the License is distributed on an "AS IS" basis,   #
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License     #
# for the specific language governing rights and limitations under the         #
# License.                                                                     #
#                                                                              #
# @auto-generated by the PyTis Copyright Tool on 12:47 PM - 16 Aug, 2024       #
############################################################################## #
# -*- coding: utf-8 -*-


# =============================================================================
# Begin Imports
# -----------------------------------------------------------------------------
# builtin
try:
  import sys
  import datetime
  import functools
  import glob
  import logging
  import platform
  import pydoc
  import optparse
  import os
  import re
  import types
  from io import StringIO

  #
  # Internal
  # (none, this should be stand alone (all function imported from pytis.py)

except KeyboardInterrupt as e:
  print("KeyboardInterrupt: %s" % str(repr(e)))
  print("Script terminated by Control-C")
  print("bye!")
  # Return Code 130 - Script terminated by Control-C
  sys.exit(130)

try:
  #
  # Third-Party
  #
  import rjsmin

except ImportError as e:
  print('minify requires a third party python library "rjsmin", please run ' \
    "\npython3 -m pip install rjsmin")
  sys.exit(1)

except KeyboardInterrupt as e:
  print("KeyboardInterrupt: %s" % str(repr(e)))
  print("Script terminated by Control-C")
  print("bye!")
  # Return Code 130 - Script terminated by Control-C
  sys.exit(130)
# -----------------------------------------------------------------------------
# End Imports
# =============================================================================
# =============================================================================
# Begin VARIABLE DEFINITIONS
# -----------------------------------------------------------------------------

# sorry, this ONE and only ONE function must be declared before the variables
# are set (as it is used to set one of them)

def logdir():
  """ Regardless of how this is installed (for all users, or a single user, to
  a system user (root) or a normal user, on linux or windows, find and return
  the correct directory for log files. """

  def local_backup():
    h = os.path.expanduser('~')
    if platform.system() == 'Windows':
      return os.path.join(h, 'PyTis', 'Logs')
    if os.path.exists(os.path.abspath(os.path.join(h, '.local'))):
      return os.path.join(h, '.local', 'logs', 'pytis')
    elif os.path.exists(os.path.abspath(os.path.join(h, '.config'))):
      return os.path.join(h, '.config', 'pytis', 'logs')
    else:
      return os.path.join(h, '.logs', 'pytis')

  basedir = os.path.abspath(os.path.dirname(__file__))
  # if installed locally
  if basedir.startswith(os.path.expanduser('~')):
    # IF WINDOWS
    if platform.system() == 'Windows':
      # if windows BUILTIN %APPDATA% doesn't exist
      app_path = os.path.expandvars('%APPDATA%')
      if app_path and  os.path.exists(os.path.abspath(app_path)):
        # okay, the windows %APPDATA% does exist, join it with what we must,
        # and return it
        path = os.path.join(app_path, 'PyTis', 'Logs')
      else:
        app_path =  os.getenv('APPDATA', 
          os.path.join(os.path.expanduser('~'), 'AppData', 'Roaming')
        )
        # then perhaps the python env one does, and if not, set a default one
        # with the pythonic dictionary default method
        path = os.path.join(app_path, 'PyTis',' Logs')
      
      try:
        # Ensure the directory exists
        os.makedirs(os.path.abspath(path), exist_ok=True)
      except PermissionError as e:
        path = local_backup()

    # ELSE NOT WINDOWS
    else:
      # Installed locally on LINUX/UNIX or CYGWIN
      path = local_backup()
  # else is installed for everyone
  else:
    # ##################################################
    # Installed for ALL USERS on WINDOWS
    if platform.system() == 'Windows':
      # Get the Windows version and directory
      win_version = platform.system()
      win_directory = os.getenv('WINDIR', 'C:\\Windows')

      if win_version == 'Windows' and platform.release() in ['7', '8', '8.1', '10', '11']:
        # Modern Windows versions, use 
        path = os.path.join(
          os.getenv('ProgramData', os.path.abspath('/ProgramData')),
          'PyTis', 'Logs'
        )
      elif win_version == 'Windows' and platform.release() in ['XP', '2000', 'Server2003']:
        # Older versions of Windows, use WINNT or WINDOWS directory
        path = os.path.join(win_directory, 'System32', 'LogFiles', 'PyTis')
      else:
        # Fallback for even older systems
        path = os.path.join(win_directory, 'PyTis', 'Logs')

    # ##################################################
    # Installed for ALL USERS on LINUX/UNIX or CYGWIN
    else:
      path = os.path.join('/var', 'log', 'pytis')
      if not os.path.exists(path):
        # Ensure the directory exists
        try:
          os.makedirs(path, exist_ok=True)
        except PermissionError as e:
          path = local_backup()

  # Ensure the directory exists
  path = os.path.abspath(path)
  os.makedirs(path, exist_ok=True)
  return path
# -----------------------------------------------------------------------------
# Okay, NOW set the variables

errors = []
__version__ = '1.0'
__author__ = 'Josh.Lee@PyTis.com'
__created__ = '06:14pm 17 Aug, 2024'
__copyright__ = 'PyTis.com'
__logdir__ = logdir()

# if this program is ever extended to have settings, when the options are
# logged to a long file, or to screen by using --verbose and --debug, the
# following settings will have their values replaced with '*****' characters as
# to not write passwords to the log files.
protected_options = (
  'aws_secret_access_key',
  'cloud_checker_access_key',
  'db_password',
  'pass',
  'password',
  'secret_access_key',
  'sr_secret_access_key',
)

__change_log__ = """
CHANGE LOG

  v1.0 ORIGINAL RELEASE                                         August 17, 2024
    Original Publish.

  v0.1.0                                                        August 10, 2024
    Initial Creation

XXX-TODO:
  Finish

"""

# -20 (most favorable to the process) to 19 (least favorable to the process)
# default 10
default_niceness = 10 

__option_always__ = [False]
__input_options__ = ['y','N']


# -----------------------------------------------------------------------------
# End VARIABLE DEFINITIONS
# =============================================================================
# =============================================================================
# Begin ERROR CLASSES BELOW
# -----------------------------------------------------------------------------

class NoFiles(Exception): pass

# -----------------------------------------------------------------------------
# End ERROR CLASSES BELOW
# =============================================================================
# =============================================================================
# Begin Import PyTis CLASSES ABLVE
# -----------------------------------------------------------------------------
class MyLogger(logging.Logger):
  _opts = None

  # 0,1,2,3,4:0=quiet,1=verbose,2=more verbose,3=most verbose,4=debug & verbose
#  opts.verbose = 0

  @property
  def opts(self):
    return self._opts

  def setOpts(self, opts):
    self._opts = opts


  '''
  def debug
  def info
  def info1
  def info2
  def info3
  def info4
  def warn
  def error
  def critical
  def fatal
  '''

  def debug(self, msg, *args, **kwargs):
    if self.opts.totally_verbose and self.opts.debug and not self.opts.quiet:
      print( msg)
    return logging.Logger.debug(self, msg, *args, **kwargs)
    
  def info(self, msg, *args, **kwargs):
    if not self.opts.quiet:
      print(msg)
    return logging.Logger.info(self, msg, *args, **kwargs)

  def info1(self, msg, *args, **kwargs):
    if not self.opts.quiet and self.opts.verbose >= 1:
      print(msg)
    if self.opts.verbose >= 1 or self.opts.debug:
      return logging.Logger.info(self, msg, *args, **kwargs)

  def info2(self, msg, *args, **kwargs):
    if not self.opts.quiet and self.opts.verbose >= 2:
      print(msg)
    if self.opts.verbose >= 2 or self.opts.debug:
      return logging.Logger.info(self, msg, *args, **kwargs)

  def info3(self, msg, *args, **kwargs):
    if not self.opts.quiet and self.opts.verbose >= 3:
      print(msg)
    if self.opts.verbose >= 3 or self.opts.debug:
      return logging.Logger.info(self, msg, *args, **kwargs)

  def info4(self, msg, *args, **kwargs):
    if not self.opts.quiet and self.opts.verbose >= 4:
      print(msg)
    if self.opts.verbose >= 4 or self.opts.debug:
      return logging.Logger.info(self, msg, *args, **kwargs)

  def warn(self, msg, *args, **kwargs):
    return self.warning(msg, *args, **kwargs)

  def warning(self, msg, *args, **kwargs):
    if not self.opts.quiet:
      print('WARNING: %s' % msg)
    return logging.Logger.warning(self, msg, *args, **kwargs)

  def error(self, msg, *args, **kwargs):
    sys.stderr.write("%s%s\n" % (('' if kwargs.get('exc_info',None) else \
      'ERROR: ') ,msg))
    return logging.Logger.error(self, msg, *args, **kwargs)

  def critical(self, msg, *args, **kwargs):
    sys.stderr.write("%s%s\n" % (('' if kwargs.get('exc_info',None) else \
      'CRITICAL: ') ,msg))
    return logging.Logger.critical(self, msg, *args, **kwargs)

  def fatal(self, msg, *args, **kwargs):
    sys.stderr.write("%s%s\n" % (('' if kwargs.get('exc_info',None) else \
      'FATAL: ') ,msg))
    logging.Logger.fatal(self, msg, *args, **kwargs)
    sys.exit(1)

  def _log(self, level, msg, args, exc_info=None):
    """
    Low-level logging routine which creates a LogRecord and then calls
    all the handlers of this logger to handle the record.
    """
    if logging._srcfile:
      fn, lno, func, stack_info  = self.findCaller()
    else:
      fn, lno, func = "(unknown file)", 0, "(unknown function)"
    if exc_info:
      if type(exc_info) != types.TupleType:
        exc_info = sys.exc_info()

    record = self.makeRecord(self.name, level, fn, lno, msg, args, exc_info)
    self.handle(record)

# ============================================================================#
class MyParser(optparse.OptionParser):
  extra_txt = None
  py_args = []
  py_opts = []
  """
  The below variable is new, but I want to have backwards compatability.  If
  you turn this variable on, and make set it to True then the print_help will
  hide the default help page which lists well formatted options and their help
  messages.  I choose to do this because while in the extra_txt, I usually
  provide additional help, in the current program I am working on the
  extra_txt represents an entire man page with greater detail on each
  individual option.  Therefore I do not wish to show the built-in,
  auto-generated help message as well.  Lastly, you won't actually set this
  variable directly, I am creating a setter and getter method to treat it as a
  property, which you should find under the __init__.  
  """
  _full_help_available = False

  def setFullHelpAvaiable(self):
    self._full_help_available=True

  def set_full_help_available(self,b):
    self._full_help_available=b
  def get_full_help_available(self):
    return self._full_help_available
  full_help_available = property(get_full_help_available, 
    set_full_help_available)

  def __init__(self,
               usage=None,
               option_list=None,
               option_class=optparse.Option,
               version=None,
               conflict_handler="error",
               description=None,
               formatter=None,
               add_help_option=True,
               prog=None,
               epilog=None):

    optparse.OptionParser. __init__(self,
               usage, option_list, option_class, version, conflict_handler, 
               description, formatter, add_help_option, prog, epilog)


  def print_out(self, txt):
    try:
      import curses
      txt = txt.replace("`$","\n")
      win=curses.initscr()
      max_x, max_y = win.getmaxyx()
      curses.endwin()
      if len(txt.split("\n")) > max_x:
        pager = pydoc.getpager()
        try:
          pager(txt)
        except (EOFError, KeyboardInterrupt) as e:
          pass
      else:
        sys.stdout.write("%s\n" % txt)
    except:
      pager = pydoc.getpager()
      try:
        pager(txt)
      except (EOFError, KeyboardInterrupt) as e:
        pass
      sys.stdout.write("%s\n" % txt)


  def print_help(self, errors=None):
    """
    NAME
    SYNOPSIS
    DESCRIPTION
    OPTIONS
    COMMANDS
    ENVIRONMENT
    SEE ALSO
    AUTHOR
    HISTORY
    VERSION
    """
    buf = StringIO()
    sys.stdout = buf

    # The user did not enter --help, they only entered -h, show short help and
    # instructions on howto view full help.
    if '--help' not in sys.argv and self.extra_txt is not None:
      # print the short usage.
      self.set_usage("%s\n%s" % (self.get_usage(), \
        "*** USE '--help' for the full help page. ***"))


    # If NOT (--help was typed in, and there is extra_text to show, and
    # full_help_available)
    if not ('--help' in sys.argv and self.extra_txt is not None and 
      self.full_help_available):
      # print help as the OptionParser normally would, without extra goodies
      optparse.OptionParser.print_help(self)


    if '--help' in sys.argv and self.extra_txt is not None and errors is None:
      self.print_out(self.extra_txt)

    if not errors:
      errors = []
    elif not isinstance(errors, list):
      errors = [errors]

    sys.stdout = sys.__stdout__
    self.print_out(buf.getvalue().replace("Options:\n", \
      "OPTIONS:\n").replace(":\n",":\n\n"))

    if errors:
      sys.stderr.write("\n")
      for error in errors:
        sys.stderr.write(fix_width("ERROR: %s\n" % error))
    sys.stderr.flush()

      # FIXME - this was in python3, does it return in python2?
#    return bool(errors)

# -----------------------------------------------------------------------------
# End Import PyTis CLASSES ABLVE
# =============================================================================
# =============================================================================
# Begin import FUNCTIONS from PyTis

def version(version=__version__):
  print("%s %s" % (os.path.splitext(os.path.basename(sys.argv[0]))[0],version))
  return 0

def relogOpts(opts, msg=None, also_protect=[]):
  """ After all config file loading, option parsing and data crunching  has 
      been completed, ths function will re-log to debug all options gathered,
      so we  can see what their values are.
  """
  global log, protected_options
  protect_these = [x for x in protected_options]
  if type(also_protect) is type(str('')): also_protect=[also_protect]
  protect_these.extend(also_protect)
  
  log.setOpts(opts)
  #opts.ip_addresses=PyTis.unique(opts.ip_addresses)

  # I want the output alphabatized, so I am going to create a list of tuples,
  # sort them, no wait, you know what would be faster? to just grab the keys,
  # sort those, request each value by key.

  log.debug('-'*80) 
  if msg: 
    log.debug(msg)

  opt_keys = list(opts.__dict__.keys())
  opt_keys.sort()
  for opt in opt_keys:

    if opt == 'version_other': continue

    value = opts.__dict__[opt]

    if opt == 'version': value = opts.version_other


    if type(value) == type(str('')):
      # function optional_arg utilizes this feature.
      if value.strip() == '_empty_val_trick_': value = ''
      if str(opt).lower() in protect_these: value = protect(value)
      if not value: value = "''"
      
    log.debug("OPTION %s: %s" % (opt,value))

  log.debug('-'*80) 
  return

def set_logging(opts, name, __logdir__=__logdir__):
  global log

  logfile_name = os.path.splitext(name)[0]
  log_file = '%s.log' % logfile_name
  name = "%s-v%s" % (os.path.splitext(name)[0], __version__)

  log_file_path = os.path.abspath(os.path.join(os.path.abspath(__logdir__), 
      log_file ))

  logging.basicConfig(
    filename=log_file_path,
    level=logging.NOTSET,
    format='%(asctime)s.%(msecs)03d %(name)-10s %(levelname)-8s ' \
      '[PID: %(process)d]  %(message)s',
    datefmt="%Y%m%d %H:%M:%S")

  logging.setLoggerClass(MyLogger)
  log = logging.getLogger(logfile_name)
#  log = logging.getLogger()
  log.setOpts(opts)
  
  if not opts.quiet and opts.version_other != True and opts.totally_verbose:
    if opts.verbose >= 2:
      log.info3("STARTING: %s at %s" % (name, prettyNow()))

  # BEGIN TRICK
  # From here to the next comment is a trick to allow the log message to goto
  # only a log file, and not make it to the screen of a user.
  # we MIGHT be using this trick again, depends on the overall verbosity, look
  # further down this function for the next occurance of sys.stdout  
  buf = StringIO() 
  sys.stdout = buf

  if opts.verbose > 0 and opts.verbose < 2:
    log.info1("STARTING: %s at %s" % (name, prettyNow()))

  sys.stdout = sys.__stdout__
  del buf
  # END TRICK

  if not opts.totally_verbose:
    # we may be using this trick again, depends on the overall verbosity, look
    # further down this function for the next occurance of sys.stdout  
    buf = StringIO()
    sys.stdout = buf

  relogOpts(opts, "Options parsed from STDIN")

  if not opts.totally_verbose:
    # and now we end our little second utilization of the output override trick
    sys.stdout = sys.__stdout__
    del buf


  if opts.debug and opts.verbose:
    log.info4("log file: %s" % log_file_path)

  return log




def filesFromPath(path, opts, cd=os.curdir):
    """ Allows me to call once per path (with or without wildcards) """

    files = []

    log.info4('filesFromPath: %s in %s' % (path, os.path.abspath(cd)))

    # Convert relative path to absolute path
    path = os.path.abspath(os.path.join(cd, path))

    if os.path.isfile(path) and os.path.exists(path):
      if opts.js and path.lower().endswith('.js') or \
        opts.css and path.lower().endswith('.css'):
        log.info3('file found in path: %s' % path)
        files.append(path)

    elif os.path.isdir(path):
      log.info4("folder found in args '%s', scanning now" % path)

      # If it's a directory, use glob to find files
      items = []
      if opts.css:
        bag = glob.glob(os.path.join(path, '*.css'))
        [log.info4('found %s' % b) for b in bag]
        items.extend(bag)
        bag = glob.glob(os.path.join(path, '*.css'))
        [log.info4('found %s' % b) for b in bag]
        items.extend(bag)

      if opts.js: 
        items.extend(glob.glob(os.path.join(path, '*.js*')))
        items.extend(glob.glob(os.path.join(path, '*.JS')))

      if opts.recursive:
        bag = glob.glob(os.path.join(path, '**/'))
        items.extend(bag)

      [files.extend( filesFromPath(item, opts) ) for item in items]

    else:
      # Handle wildcards or single file pattern
      log.info4("wildcards found in  '%s', scanning now" % path)
      items = glob.glob(os.path.abspath(path))
      for item in items:
        if os.path.isfile(item) and \
          (opts.js and item.lower().endswith('.js') or \
          opts.css and item.lower().endswith('.css')):
            files.append(item)
        elif os.path.isdir(item) and opts.recursive:
          files.extend( filesFromPath(item, opts) )
          #  there are no cases where this else will run
          pass

    # Filter the list to only include files (ignore directories)
    files = [f for f in files if os.path.isfile(f) and os.path.exists(f)]

    return files

def filesFromArgs(opts, args):
    """
    Process arguments to collect files, handling directories and wildcards.
    """
    if opts.debug: log.info4('scanning input from STDIN')
    return [f for arg in args for f in filesFromPath(arg, opts) \
      if not f.lower().endswith(('.min.css', '.min.js')) ]

def prettyNow():
  return datetime.datetime.now().strftime("%I:%M%%s %m %b, %Y") % \
    datetime.datetime.now().strftime("%p").lower()

def fix_width(text, width=79):
  """
  A word-wrap function that preserves existing line breaks
  and most spaces in the text. Expects that existing line
  breaks are posix newlines (\n).
  """
  return functools.reduce(lambda line, word, width=width: '%s%s%s' % (line,
  ' \n'[(len(line)-line.rfind('\n')-1 + len(word.split('\n',1)[0])>=width)],
  word), text.split(' '))


# -----------------------------------------------------------------------------
# End import FUNCTIONS from PyTis
# =============================================================================
# =============================================================================
# Begin CSS PROGRAM FUNCTIONS 
# -----------------------------------------------------------------------------

def remove_comments(css):
    """Remove all CSS comment blocks."""

    iemac = False
    preserve = False
    comment_start = css.find("/*")
    while comment_start >= 0:
        # Preserve comments that look like `/*!...*/`.
        # Slicing is used to make sure we don"t get an IndexError.
        preserve = css[comment_start + 2:comment_start + 3] == "!"

        comment_end = css.find("*/", comment_start + 2)
        if comment_end < 0:
            if not preserve:
                css = css[:comment_start]
                break
        elif comment_end >= (comment_start + 2):
            if css[comment_end - 1] == "\\":
                # This is an IE Mac-specific comment; leave this one and the
                # following one alone.
                comment_start = comment_end + 2
                iemac = True
            elif iemac:
                comment_start = comment_end + 2
                iemac = False
            elif not preserve:
                css = css[:comment_start] + css[comment_end + 2:]
            else:
                comment_start = comment_end + 2
        comment_start = css.find("/*", comment_start)

    return css


def remove_unnecessary_whitespace(css):
    """Remove unnecessary whitespace characters."""

    def pseudoclasscolon(css):

        """
        Prevents 'p :link' from becoming 'p:link'.

        Translates 'p :link' into 'p ___PSEUDOCLASSCOLON___link'; this is
        translated back again later.
        """

        regex = re.compile(r"(^|\})(([^\{\:])+\:)+([^\{]*\{)")
        match = regex.search(css)
        while match:
            css = ''.join([
                css[:match.start()],
                match.group().replace(":", "___PSEUDOCLASSCOLON___"),
                css[match.end():]])
            match = regex.search(css)
        return css

    css = pseudoclasscolon(css)
    # Remove spaces from before things.
    css = re.sub(r"\s+([!{};:>+\(\)\],])", r"\1", css)

    # If there is a `@charset`, then only allow one, and move to the beginning.
    css = re.sub(r"^(.*)(@charset \"[^\"]*\";)", r"\2\1", css)
    css = re.sub(r"^(\s*@charset [^;]+;\s*)+", r"\1", css)

    # Put the space back in for a few cases, such as `@media screen` and
    # `(-webkit-min-device-pixel-ratio:0)`.
    css = re.sub(r"\band\(", "and (", css)

    # Put the colons back.
    css = css.replace('___PSEUDOCLASSCOLON___', ':')

    # Remove spaces from after things.
    css = re.sub(r"([!{}:;>+\(\[,])\s+", r"\1", css)

    return css


def normalize_rgb_colors_to_hex(css):
    """Convert `rgb(51,102,153)` to `#336699`."""
    regex = re.compile(r"rgb\s*\(\s*([0-9,\s]+)\s*\)")
    match = regex.search(css)
    while match:
        colors = map(lambda s: s.strip(), match.group(1).split(","))
        hexcolor = '#%.2x%.2x%.2x' % tuple(map(int, colors))
        css = css.replace(match.group(), hexcolor)
        match = regex.search(css)
    return css

def condense_multidimensional_zeros(css):
    """Replace `:0 0 0 0;`, `:0 0 0;` etc. with `:0;`."""
    css = css.replace(":0 0 0 0;", ":0;")
    css = css.replace(":0 0 0;", ":0;")
    css = css.replace(":0 0;", ":0;")

    # Revert `background-position:0;` to the valid `background-position:0 0;`.
    css = css.replace("background-position:0;", "background-position:0 0;")
    return css

def condense_hex_colors(css):
    """Shorten colors from #AABBCC to #ABC where possible."""

    regex = re.compile(r"([^\"'=\s])(\s*)#([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])")
    match = regex.search(css)
    while match:
        first = match.group(3) + match.group(5) + match.group(7)
        second = match.group(4) + match.group(6) + match.group(8)
        if first.lower() == second.lower():
            css = css.replace(match.group(), match.group(1) + match.group(2) + '#' + first)
            match = regex.search(css, match.end() - 3)
        else:
            match = regex.search(css, match.end())
    return css

def remove_unnecessary_semicolons(css):
    """Remove unnecessary semicolons."""
    return re.sub(r";+\}", "}", css)

def remove_empty_rules(css):
    """Remove empty rules."""
    return re.sub(r"[^\}\{]+\{\}", "", css)

def condense_zero_units(css):
    """Replace `0(px, em, %, etc)` with `0`."""
    return re.sub(r"([\s:])(0)(px|em|%|in|cm|mm|pc|pt|ex)", r"\1\2", css)

def condense_floating_points(css):
    """Replace `0.6` with `.6` where possible."""
    return re.sub(r"(:|\s)0+\.(\d+)", r"\1.\2", css)

def condense_whitespace(css):
    """Condense multiple adjacent whitespace characters into one."""
    return re.sub(r"\s+", " ", css)


def condense_semicolons(css):
    """Condense multiple adjacent semicolon characters into one."""
    return re.sub(r";;+", ";", css)

def cssmin(css):
  global log
  log.info3('removing comments')
  css = remove_comments(css)
  log.info3('condensing whitespace')
  css = condense_whitespace(css)
  # A pseudo class for the Box Model Hack
  # (see http://tantek.com/CSS/Examples/boxmodelhack.html)
  css = css.replace('"\\"}\\""', "___PSEUDOCLASSBMH___")
  css = remove_unnecessary_whitespace(css)
  log.info3('removing unnecessary semicolons')
  css = remove_unnecessary_semicolons(css)
  log.info3('condensing zero units')
  css = condense_zero_units(css)
  log.info3('condensing multidimensional units')
  css = condense_multidimensional_zeros(css)
  log.info3('condensing floating points')
  css = condense_floating_points(css)
  log.info3('normalizing rgb colors to hex')
  css = normalize_rgb_colors_to_hex(css)
  log.info3('condensing hex colors')
  css = condense_hex_colors(css)
  css = css.replace("___PSEUDOCLASSBMH___", '"\\"}\\""')
  log.info3('condensing semicolons')
  css = condense_semicolons(css)
  return css.strip()


# -----------------------------------------------------------------------------
# End CSS PROGRAM FUNCTIONS 
# =============================================================================
# =============================================================================
# Begin JS PROGRAM FUNCTIONS 
# -----------------------------------------------------------------------------

def minify_js(js_text):
    # Minify the JavaScript content
    return rjsmin.jsmin(js_text).replace("\r\n","\n").replace("\n",'')

# -----------------------------------------------------------------------------
# End JS PROGRAM FUNCTIONS 
# =============================================================================



def run(opts, args):
  """
  To minify ALL CSS files, simply run:

    mini `find . -iname '*.css'` -- passing in all file names, find will look in
        child directories.
    mini -rj -- this will do the same as above, find ll CSS files, recursively
        (in all child directories)

  To minify ALL JS files, simply run:

    mini `find . -iname '*.js'` -- passing in all file names, find will look in
        child directories.
    mini -rj -- this will do the same as above, find ll JS files, recursively
        (in all child directories)

    mini '*.css'`-- will match all the CSS files in the current directory
    mini *.css  `-- will match all the CSS files in the current directory
    mini -c  `-- will match all in the CSS files the current directory

    mini '*.js'`-- will match all the JS files in the current directory
    mini *.js  `-- will match all in the JS files in the current directory
    mini -j  `-- will match all in the JS files in the current directory

  You may combine [-c/--css] with [-j/--js]

  To minify a SPECIFIC CSS file, run:
      mini [FILENAME(s)]

  To minify a SPECIFIC JavaScript file, run:
      mini [FILENAME(s)]


  """ 
  global log

  os.nice(opts.niceness)

  files = filesFromArgs(opts, args)
  if not files:
    raise NoFiles('No files found')
  else:
    files = sorted(set(files))

  total = len(files)

  if not opts.quiet and not opts.verbose:
    print("Please wait,..", end='', flush=True)

  for i, f in enumerate(files):
    i+=1
    percent = round(i*100/total,2)
    if percent > 100:
      percent = 100

    if not opts.quiet and not opts.verbose:
      print('\r%s%% complete' % percent, end='', flush=True)

    if f.lower().endswith('.css'):
      log.info1('minifying\t%s' % f)
      with open(f, 'r') as file:
        # Create the new filename with .min.css extension
        new_filename = os.path.splitext(f)[0] + ".min.css"
        handle = open(new_filename.replace('.min.min','.min'), 'w+')
        handle.write(cssmin(file.read()))
        handle.close()
        log.info1('wrote\t\t%s' % new_filename)

    elif f.lower().endswith('.js'):
      log.info1('minifying\t%s' % f)
      with open(f, 'r') as file:
        # Create the new filename with .min.js extension
        new_filename = os.path.splitext(f)[0] + ".min.js"
        handle = open(new_filename.replace('.min.min','.min'), 'w+')
        handle.write(minify_js(file.read()))
        handle.close()
        log.info1('wrote\t\t%s' % new_filename)


    else:
      print("%s is not a CSS or JS file." % f)
  
  return 0

def main():
  """%prog <options> [CSS or JS file or files] """
  global errors, log

  # first arg will be this program name.
  prog_path = os.path.basename(sys.argv[0]) 
  prog_name = os.path.splitext(os.path.basename(prog_path))[0] 

  parser = MyParser()

  parser.extra_txt = "\n\n%s\n" % run.__doc__ + """

-------------------------------------------------------------------------------

SEE ALSO:

  getip 
  rjsmin
  cssmin

COPYRIGHT:

  %(copyright)s

AUTHOR:

  %(author)s

CREATED:

  %(created)s

VERSION:

  %(version)s

HISTORY:

  Original Author

%(change_log)s

XXX-R
  1. CSS remove_empty_rules is not currently being called.  It needs further
     testing before being initialized.
  2. Finish cleanup.

EXAMPLES:  

  minify -r .
    (same as)
  minify -r -c -j .

  minify -r '*.css'
    (same as)
  minify -r *.css
    (same as)
  minify -r -c

  minify -r '*.js'
    (same as)
  minify -r *.js
    (same as)
  minify -r -j

  minify -dv

  minify -v

  minify -vv

  minify -vvv


BUGS - KNOWN ISSUES:

  NONE (at tis time).

"""  % dict(version=__version__,
             author=__author__,
             change_log=__change_log__,
             created=__created__,
             copyright=__copyright__)
  # ----------------------------
#  parser.formatter.format_description = lambda s:s
  parser.set_usage(main.__doc__)

  if '--help' in sys.argv:
    parser.set_description(__doc__)
    # ----------------------------------------------------------------------- |
    # runtime variable setting
    # ----------------------------------------------------------------------- |
    runtime = optparse.OptionGroup(parser, "-- RUNTIME ARGUMENTS",
      description="\tCommon flags most users should be aware of.\n"
    )
    # ----------------------------
    runtime.add_option("-c", "--css", action="store_true", default=False,
      metavar='CSS', dest='css',
      help="CSS only (when using 'minify --css *.*' skips minifying " \
      "JavaScript files).`$")
    # ----------------------------
    runtime.add_option("-j", "--js", action="store_true", default=False,
      metavar='JavaScript', dest='js',
      help="JS only (when using 'minify --js *.*' skips minifying " \
      "CSS files).`$")
    runtime.add_option("", "--javascript", action="store_true", default=False,
      dest='js', help=optparse.SUPPRESS_HELP)
    # ----------------------------
    runtime.add_option("-r", "--recursive", action="store_true", default=False,
      metavar='Recursive', dest='recursive',
      help="In addtion to passing in a file or list of files, this program " \
        "can also receive a path or list of paths.  When a path is " \
        "received, it will automatically scan for CSS and JS files " \
        "(see -c/--css, -j/--js); by default this is done itteravely, " \
        "which means child directories are not also searched.`" \
        "If you wish subfolders to also be searched, pass in this argument " \
        "([-r/--recursive]).`$")

    # ----------------------------
    parser.add_option_group(runtime)
    # ----------------------------------------------------------------------- |
    # ------------------------------------------------------------------------ |
    vars = optparse.OptionGroup(parser, "-- ADVANCED SETTINGS",
      description="\tIf you are minifying a particularly large amount of " \
        "files,\n\tyou can specify limits on CPU, memory, and disk usage.\n"
    )

    vars.add_option("-N", "--nice", type="int", action='store',
       default=default_niceness, 
       dest='niceness', metavar='[INT <-20 to 19>]',
       help="Niceness range from -20 (most favorable scheduling) to 19 " \
       "(least favorable); default 10 " \
       "(for more information, please run: 'man nice').`$")
    # no other advanced settings at this time, but this is where we'd put them

    parser.add_option_group(vars)
    # ------------------------------------------------------------------------ |
    dbgroup = optparse.OptionGroup(parser, "-- Logging Options")

    dbgroup.add_option("-d", "--debug", action="store_true", default=False,
      dest='debug',
      help= "Enable debugging.  When debugging is enabled, this " \
        "program will utilize it's own log file ('minify.log') logging will " \
        "write to the ('pytis-tools.log') when this option is NOT enabled.  " \
        "When utilizing the [-d/--debug] flag, debug statements will " \
        "also print to the screen, unless you suppress them with the " \
        "[-q/--quiet] flag.`$")

    # This is a little trick to tell if the user entered the -v/--verbose flag.
    # We want verbosity on by default, but we also want to know if the user
    # entered it for debug items, and providing end messages vs informed output.
    dbgroup.add_option("", "--totaly-verbose", action="store_true",
      default=False, dest='totally_verbose', help=optparse.SUPPRESS_HELP)

    dbgroup.add_option('-v', '--verbose', action='count', default=0,
      dest='verbose',
      help="Be more Verbose (make lots of noise).  The more v's you " \
        "provide, the more verbose I will be.`$")

    dbgroup.add_option("-q", "--quiet", action="store_true",
      default=False, dest='quiet',
      help="be vewwy quiet (I'm hunting wabbits).  On by default.`$")

    dbgroup.add_option("", "--version-other", action="store_true",
             default=False, dest='version_other',
             help=optparse.SUPPRESS_HELP)

    dbgroup.add_option("-V", "--version", action="store_true",
             default=False, dest='version',
             help="Display Version")

    parser.add_option_group(dbgroup)


  else:
    parser.set_description('')
    parser.setFullHelpAvaiable()

    # ------------------------------------------------------------------------ |
    parser.add_option("-c", "--css", action="store_true", default=False,
      metavar='CSS', dest='css',  help='CSS files only')
    # ----------------------------
    parser.add_option("-j", "--js", action="store_true", default=False,
      metavar='JavaScript', dest='js', help='JS files only')
    # ----------------------------
    parser.add_option("-r", "--recursive", action="store_true", default=False,
      metavar='Recursive', dest='recursive', help="Iterative by default`$")
    # ----------------------------
    parser.add_option("-N", "", type="int", action='store',
       default=default_niceness, dest='niceness', metavar='[INT <-20 to 19>]',
       help='')
    parser.add_option("", "--nice", type="int", action='store',
       default=default_niceness, dest='niceness', metavar='[INT <-20 to 19>]',
       help="CPU priority [INT <-20 to 19>], default %s.`$" % default_niceness)
    # ------------------------------------------------------------------------ |
    # This is a little trick to tell if the user entered the -v/--verbose flag.
    # We want verbosity on by default, but we also want to know if the user
    # entered it for debug items, and providing end messages vs informed output.
    parser.add_option("", "--totaly-verbose", action="store_true",
      default=False, dest='totally_verbose', 
      help=optparse.SUPPRESS_HELP)
    # ----------------------------
    parser.add_option("-d", "--debug", action="store_true",
       default=False, dest='debug', help="Enable debugging")
    # ----------------------------
    parser.add_option('-v', '--verbose', action='count', default=0,
      dest='verbose', help='Increase verbosity')
    # ----------------------------
    parser.add_option("-q", "--quiet", action="store_true",
             default=False, dest='quiet',
             help="Be vewwy quiet (I'm hunting wabbits).  On by default.`$")
    # ----------------------------
    parser.add_option("", "--version-other", action="store_true",
             default=False, dest='version_other',
             help=optparse.SUPPRESS_HELP)
    parser.add_option("-V", "--version", action="store_true",
             default=False, dest='version',
             help="Display Version")
    # ----------------------------
#      '`$*(use "--help" for more details)`$'
  # ------------------------------------------------------------------------ |
  # -------------------------------------------------------------------------
#  parser.set_description(main.__doc__)
    
  opts, args = parser.parse_args()

  # if NEITHER CSS nor JS were specified, then by default, just scan for both
  if not opts.css and not opts.js:
    opts.css = opts.js = True

  if opts.verbose: 
    # now we know that the user delared verbosity on
    opts.totally_verbose = True

#  if not opts.quiet and not opts.verbose:
#    opts.verbose=1

  if opts.quiet:
    opts.totally_verbose = False
  else:
    pass
#    opts.totally_verbose = True

  #if not opts.quiet: opts.verbose = True # Defaults to Verbose
#  if not opts.verbose: opts.quiet = True # Defaults to Quiet 
  # ----------------------------

  opts.version_other = opts.version
  opts.version = True
  if not opts.version_other:
  # I bet half of my programs or more are missing this if statement
    log = set_logging(opts, os.path.basename(sys.argv[0]))
  opts.version = opts.version_other

  if opts.version:
    return version()
  # ----------------------------

  try:
    if(args):
      sys.exit(run(opts, args))
    else:
      log.error("No file or files provided, I have nothing to minify for " \
        "you.\n")

      if not opts.quiet:
        print("" + parser.get_usage())

      print("Use '-h' for a list of commands or '--help' to view the " \
        "complete manual.")

      if not opts.quiet:
        print("\nbye!")
  except NoFiles as e:
    parser.print_usage()
    log.error(str(e))
    if not opts.quiet:
      print("\nbye!")
  except KeyboardInterrupt as e:
    parser.print_usage()
    print("\nbye!")
    

if __name__ == '__main__':
  try:
    sys.exit(main())
  except Exception as e:
    print("An error has occured.\n")
    print(str(e))
    sys.exit(1)

